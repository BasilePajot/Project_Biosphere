---
title: "Script V0 pour traiter les données brutes microbiotes bactéries"
author: "Jacques_DAVID-Basile_PAJOT"
date: '2022-06-30'
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Libraries

```{r}
# Installing and importing all the necessary libraries
# install.packages("anyLib") # Importing the library(use if you don't already have it)
library(anyLib)  # This library allows you to import (if it is not already the case) and load all the selected libraries
anyLib(c("FactoMineR", "lme4", "dendextend", "viridis", "mlmm.gwas", "tidyverse", "dbplyr", "stringr", "ggplot2"))

# Setting the working directory of the project (it must be changed when you use it on your computer. Set it to your project directory)

setwd("C:/Documents/ECOLE/2021-2022 Montpellier SupAgro/Stage/Stage 2A et césure/Stage CBGP - ARCAD/Données/Jacques/Jacques_project_bacteria")
par(mfrow = c(1, 1)) # Default plotting system
```

# Function definition

## Definition of the Hdeux function

This function allows to calculate the environmental and genetic variance of the input (a vector and a table) by using a mixed linear model.

```{r}
Hdeux <- function(X, CO) {
  mod <- lmer(X ~ (1|EPO) + BLOC, data = CO)  # Fits a linear mixed model defining the phenotype as a combination of a random genotype and a fixed environmental placement
  VG <- data.frame(VarCorr(mod))[1,4]         # Calculating the genetic variability in the model thanks to the estimated variance and covariance of the genetic effect on the phenotype
  VE <- data.frame(VarCorr(mod))[2,4]         # Calculating the environmental variabilility in the model thanks to the estimated variance and covariance of the environmental effect on the phenotype
  return(c(VG, VE))  # And we return the three calculated variance and covarianceof the model
}
```

## Definition of the blups function

This function allows us to calculate the BLUPS of a data set thanks to a mixed linear model

```{r}
blups <- function(X, CO) {
  mod <- lmer(X ~ (1|EPO) + BLOC, data = CO)  # Here, we define a mixed model where X is the phenotype (here, the axis of the PCA), (1|EPO) is the random effect of the genotype on the phenotype and BLOC is the fixed effect of the environment on the phenotype.
  BL <- ranef(mod) # Here, we extract the conditional means of the random effect of the fitted mixed model above. 
  return(BL) # And we return the conditional means of the mixed linear model above
}
```


## Taking out NAs of a contingency table

The input of this function is a data frame. The output is a data frame without any NAs

```{r}
NAsout <- function(x) {
  freq <- table(x) # Making a contingency table of the  selected data frame
  x[is.na(x)] <- as.integer(names(which.max(freq))) # Taking out the NAs in the names of the created contingency table
  return(x)
}
```

# Import of the data and filtering the useful one

```{r}
A <- as.data.frame(read.table("C:/Documents/ECOLE/2021-2022 Montpellier SupAgro/Stage/Stage 2A et césure/Stage CBGP - ARCAD/Données/Jacques/Jacques_project_bacteria/OTU_16S_EPO 050422-copy.csv", sep = ";", header = TRUE))   # This should be changed on your computer (the route is different)

A <- A[-which(A$otu_id == "no data"),] # Taking out all the lines with no data

# Transforming the numbers into numeric data
C <- apply(A[, 12:ncol(A)], 2, as.numeric) # conversion of the numeric data into numeric type
A <- cbind(A[, 1:11], C) # Replacing the numbers in the table with the new converted numeric data

# Here, we sort the data table to keep only 
JA <- A %>%  
  filter(Kingdom != "no data",            # Filtering the data on the different taxonomic levels to take out only the multi-affiliations
        Phylum != "Multi-affiliation",
        Phylum != "no data",
        Class != "Multi-affiliation",
        !str_detect(Family, "unknown"),
        Family != "Multi-affiliation",
        Species != "Multi-affiliation") %>%
  select(-c(otu_id, blast_perc_identity, seed_sequence, observation_sum))  # Taking out the unused columns on which the group_by function will not be able to act
Taxa <- as.data.frame(JA[, 1:7])
JA <- JA %>% 
  select(-c(Kingdom, Phylum, Class, Order, Family, Genus, Species)) %>% 
  apply(2, as.numeric) %>% 
  as.data.frame() %>% 
  mutate(aggreg = paste(Taxa$Kingdom, Taxa$Phylum, Taxa$Class, Taxa$Order, Taxa$Family, Taxa$Genus, sep = "_")) %>% # Making one column with the total name of the sample
  group_by(aggreg) %>% 
  summarise_each(sum) %>% 
  separate(aggreg, c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus")) %>% 
  as.data.frame()
# Here, we lost the name of the species
C <- apply(JA[, 7:ncol(JA)], 2, as.numeric) # conversion of the numeric data into numeric type
JA <- cbind(JA[, 1:6], C) # Replacing the numbers in the table with the new converted numeric data


JF <- A %>%  
  filter(Kingdom != "no data",            # Filtering the data on the different taxonomic levels to keep only the things we know 
        Phylum != "Multi-affiliation",
        Phylum != "no data",
        Class != "Multi-affiliation",
        !str_detect(Class, "unknown"),
        !str_detect(Order, "unknown"),
        Order != "Multi-affiliation",
        !str_detect(Family, "unknown"),
        Family != "Multi-affiliation",
        !str_detect(Genus, "unknown"),
        Genus != "Multi-affiliation", 
        !str_detect(Species, "unknown"),
        Species != "Multi-affiliation") %>%
  select(-c(otu_id, blast_perc_identity, seed_sequence, observation_sum)) %>% 
  group_by(Kingdom, Phylum, Class, Order, Family, Genus, Species) %>% 
  summarise_each(sum) %>% 
  as.data.frame()
C <- apply(JF[, 8:ncol(JF)], 2, as.numeric) # conversion of the numeric data into numeric type
JF <- cbind(JF[, 1:7], C) # Replacing the numbers in the table with the new converted numeric data


# We add cluster numbers to the JA and JF file to treat each different taxa with a new name. Each number is independent between tables A, JA and JF. They are generated arbitrarily.
JA$otu_id <- paste0("Cluster_", rownames(JA))
JF$otu_id <- paste0("Cluster_", rownames(JF))

# Calculating the total number of reads in the three tables
readsA <- sum(colSums(A[12:ncol(A)]))
readsJA <- sum(colSums(JA[8:(ncol(JA)-1)]-1))
readsJF <- sum(colSums(JF[8:(ncol(JF)-1)]-1))
readsmethod <- as.data.frame(rbind(readsA, readsJA, readsJF)) %>% 
  mutate(method = c("readsA", "readsJA", "readsJF"))

# Plotting the relative loss of each method
ggplot(readsmethod,aes(x= method, y = V1, fill = method))+
  geom_col()

dim(A)                     # Print out the initial dimension of the table to observe the changes
dim(JA)                    # Print out the initial dimension of the table to observe the changes
dim(JF)                    # Print out the initial dimension of the table to observe the changes

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(C, Taxa, readsJA, readsJF, readsA, readsmethod)
```


# Visualisation and sorting of the data by their distribution

```{r}
# Keeping only the data on the different clusters considering the wheat lines and take out ELAX.252.R2 and ELAX.453.R2 that come out massively in the PCA otherwise (they may be soil bacteria)
SA <- A[, 12:247] %>% 
  select(-c(65, 160))
SJA <- JA[, 7:242] %>% 
  select(-c(65, 160))
SJF <- JF[, 8:243] %>% 
  select(-c(65, 160))

# We add the number of the clusters to the new file
rownames(SA) <- A$otu_id
rownames(SJA) <- JA$otu_id
rownames(SJF) <- JF$otu_id

# Calculating the total number of reads per EPO (how many reads do we find per EPO?) for each table
sommeA <- apply(SA, 2, sum)
sommeJA <- apply(SJA, 2, sum)
sommeJF <- apply(SJF, 2, sum)
# Calculating the total number of reads depending on the considered cluster (how many reads are there per cluster/taxonomic group?) for each table
sommeCA <- apply(SA, 1, sum)
sommeCJA <- apply(SJA, 1, sum)
sommeCJF <- apply(SJF, 1, sum)

# We plot the results to have an idea of the distribution of the EPOs per cluster or taxonomic group
par(mfrow = c(3,1))
hist(log10(sommeCA), main = "Distribution of the number of reads per cluster")
hist(log10(sommeCJA), main = "Distribution of the number of reads per \ntaxonomic group")
hist(log10(sommeCJF), main = "Distribution of the number of reads per \ntaxonomic group")
par(mfrow = c(1,1))

# We select the clusters/taxonomic groups in which there are more than 500 reads. For now, we will only do this on the first table given the number of clusters/taxonomic groups is not as high as before in the other tables
liste_clusterA <- which(sommeCA > 500)  # For that, we make a list giving us the number of the lines in which there are more than 500 reads per cluster
SA <- SA[liste_clusterA, ]    # Then we use the list of numbers to select the right clusters in the table and keep only the ones that have more than 500 reads

# Calculation of the new size of the tables we will work with
dim(SA)
dim(SJA)
dim(SJF)

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(liste_clusterA, sommeCA, sommeCJA, sommeCJF)
```

# Working on the abondance of reads per EPO

```{r}
# We calculate the abundance using the last matrix with the sorted data by size and transform it to be able to manipulate the clusters/taxonomic groups more easily. The abundance represents the proportion of reads of each cluster/taxonomic group per EPO. We use the effectives of the reads per EPO and taxonomic group and divide it by the total number of reads per EPO
ABONDANCE_A <- t(SA) / sommeA 
ABONDANCE_JA <- t(SJA) / sommeJA
ABONDANCE_JF <- t(SJF) / sommeJF

# Getting to know the dimensions of the newly created tables
dim(ABONDANCE_A)
dim(ABONDANCE_JA)
dim(ABONDANCE_JF)

# As we took the transposed matrix of SA/SB, we have to re-attribute the names of the columns to the lines
rownames(ABONDANCE_A) <- colnames(SA)
rownames(ABONDANCE_JA) <- colnames(SJA)
rownames(ABONDANCE_JF) <- colnames(SJF)

# Here, we plot the distribution of the abundances of EPOs for each cluster/taxonomic group. As the three tables do not have the same number of columns, we have to use three loops (one for table A and one for table B)
par(mfrow = c(5,5)) # Defining parameter to have 5 graph windows
for (i in seq_along(1:ncol(ABONDANCE_A))) {
  name <- paste0("Distribution of the number of \nEPOs for cluster ", i, " in \ntable A") # Making a variable name to be able to recognize the plot
  hist(ABONDANCE_A[, i], main = name, xlab = "Abundance") # Plot of the column i in the table A
}
par(mfrow = c(1, 1)) # Returning the parameter to normal

par(mfrow = c(5, 5)) # Making a second 5*5 window so the plots in the tables don't get mixed up
for(i in seq_along(1:ncol(ABONDANCE_JA))) {
  name <- paste0("Distribution of the number \nof EPOs for \ntaxonomic group ", i, " in table JA") # Making a variable name to be able to recognize the plot
  hist(ABONDANCE_JA[, i], main = name, xlab = "Abundance")  # Plot of the column i in the table JA
}
par(mfrow = c(1, 1)) # Returning the parameter to normal

par(mfrow = c(5, 5)) # Making a second 5*5 window so the plots in the tables don't get mixed up
for(i in seq_along(1:ncol(ABONDANCE_JF))) {
  name <- paste0("Distribution of the number \nof EPOs for \ntaxonomic group ", i, " in table JF") # Making a variable name to be able to recognize the plot
  hist(ABONDANCE_JF[, i], main = name, xlab = "Abundance")  # Plot of the column i in the table JF
}
par(mfrow = c(1, 1)) # Returning the parameter to normal

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(name, i)
dev.off()
```

# Analysis on the Abundance

## Scaled PCA

```{r}
# Taking out points in the ABONDANCE_JF matrix that are too much away from the analysis cloud
ABONDANCE_JF <- ABONDANCE_JF %>%
  as.data.frame() %>% 
  rownames_to_column("names") %>% 
  filter(names != "ELAX.101.R1", 
         names != "ELAX.241.R2") %>% 
  column_to_rownames("names") %>% 
  as.matrix()
# Making a PCA on the number of EPOs per cluster/taxonomic group
ACPA <- PCA(ABONDANCE_A, scale.unit = TRUE, ncp = 40, graph = TRUE)
ACPJA <- PCA(ABONDANCE_JA, scale.unit = TRUE, ncp = 40, graph = TRUE)
ACPJF <- PCA(ABONDANCE_JF, scale.unit = TRUE, ncp = 40, graph = TRUE)

# Plotting the result of the PCA
plot.PCA(ACPA, axes = c(1, 2), choix = "ind", habillage = 13) 
plot.PCA(ACPJA, axes = c(1, 2), choix = "ind", habillage = 2)
plot.PCA(ACPJF, axes = c(1, 2), choix = "ind", habillage = 1, xlim = c(-15,20))

# We take out the coordinates of each EPO in every dimension of the 40 dimensions space in which the PCA is executed
CO_ACPA <- as.data.frame(ACPA$ind$coord)
CO_ACPJA <- as.data.frame(ACPJA$ind$coord)
CO_ACPJF <- as.data.frame(ACPJF$ind$coord)

# We print the head of the eigenvalues to see if the variance - Covariance matrix is well spread
head(ACPA$eig)
head(ACPJA$eig)
head(ACPJF$eig)
```

## Getting the heritability of the PCA data

```{r}
# We add three columns in each table of CO_ACP to have the number of the EPO and the number of the BLOC
CO_ACPA$EPO <- sapply(strsplit(rownames(CO_ACPA), "[.]"), "[", 2)
CO_ACPA$BLOC <- sapply(strsplit(rownames(CO_ACPA), "[.]"), "[", 3)
CO_ACPJA$EPO <- sapply(strsplit(rownames(CO_ACPJA), "[.]"), "[", 2)
CO_ACPJA$BLOC <- sapply(strsplit(rownames(CO_ACPJA), "[.]"), "[", 3)
CO_ACPJF$EPO <- sapply(strsplit(rownames(CO_ACPJF), "[.]"), "[", 2)
CO_ACPJF$BLOC <- sapply(strsplit(rownames(CO_ACPJF), "[.]"), "[", 3)


# We rename the columns of the dimensions in the columns to be able to use them more freely in the code
names(CO_ACPA)[1:40] <- paste0("D", 1:40)
names(CO_ACPJA)[1:40] <- paste0("D", 1:40)
names(CO_ACPJF)[1:40] <- paste0("D", 1:40)


# In this loop, we will calculate the genetic and environmental variance of the 40 dimensions in the table for each EPO. First we initialise the vectors that will be implemented with the values of the variance
RES_ACPA <- c()
RES_ACPJA <- c()
RES_ACPJF <- c()
for (i in 1:40) {
  RES_ACPA <- c(RES_ACPA, c(i, Hdeux(CO_ACPA[,i], CO_ACPA)) )# At each passage, it uses the Hdeux function defined in the beginning and implements its output into the vector used for this
  RES_ACPJA <- c(RES_ACPJA, c(i, Hdeux(CO_ACPJA[,i], CO_ACPJA)) )
  RES_ACPJF <- c(RES_ACPJF, c(i, Hdeux(CO_ACPJF[,i], CO_ACPJF)) )
}

# Changing the vectors into data frames so they can be treated more easily throughout the code
RES_ACPA <- as.data.frame(matrix(RES_ACPA, ncol = 3, byrow = TRUE))
RES_ACPJA <- as.data.frame(matrix(RES_ACPJA, ncol = 3, byrow = TRUE))
RES_ACPJF <- as.data.frame(matrix(RES_ACPJF, ncol = 3, byrow = TRUE))

# Naming the columns to manipulate them easily
names(RES_ACPA) <- c("axe", "VG", "VE")
names(RES_ACPJA) <- c("axe", "VG", "VE")
names(RES_ACPJF) <- c("axe", "VG", "VE")

# Calculating the heritability of each dimension using the formula H² = VG/(VG + VE)
RES_ACPA$H2 <- RES_ACPA$VG / (RES_ACPA$VG + RES_ACPA$VE)
RES_ACPJA$H2 <- RES_ACPJA$VG / (RES_ACPJA$VG + RES_ACPJA$VE)
RES_ACPJF$H2 <- RES_ACPJF$VG / (RES_ACPJF$VG + RES_ACPJF$VE)

# Plotting the heritability of the 40 axis to look at it
plot(1:40, RES_ACPA$H2)
plot(1:40, RES_ACPJA$H2) # The heritability is less important for the three modified table but there is still a pretty good heritability (max at 0.3 - 0.35)
plot(1:40, RES_ACPJF$H2)

# Filtering the axis for which the heritability is superior to 0.10
liste_axe_ACPA <- which(RES_ACPA$H2 >= 0)
liste_axe_ACPJA <- which(RES_ACPJA$H2 >= 0)
liste_axe_ACPJF <- which(RES_ACPJF$H2 >= 0)

# Plotting the coordinates of the EPOs on the heritable axis (H² > 0.10). As the three lists are not the same size, we have to make three distinct loops 
par(mfrow = c(3, 3)) # Asking the plots to be in a 3*3 plotting space
for (i in liste_axe_ACPA) {
  boxplot(CO_ACPA[, i] ~ CO_ACPA$EPO, ylab = paste("Coordinates on axis", i), main = paste("Table A: coordinates according to \naxis" ,i))
} # In this table, the interesting axis to explore are the 8 and 13 mainly
par(mfrow = c(1, 1))
par(mfrow = c(3, 3))
for (i in liste_axe_ACPJA) {
  boxplot(CO_ACPJA[, i] ~ CO_ACPJA$EPO, ylab = paste("Coordinates on axis", i), main = paste("Table JA: coordinates according to \naxis" ,i))
} # In this table, the interesting axis to explore are the 9, 25, 30 and 31
par(mfrow = c(1, 1)) # Returning the parameter to normal
par(mfrow = c(3, 3))
for (i in liste_axe_ACPJF) {
  boxplot(CO_ACPJF[, i] ~ CO_ACPJF$EPO, ylab = paste("Coordinates on axis", i), main = paste("Table JF: coordinates according to \naxis" ,i))
} # In this table, the interesting axis to explore are the 2 and 13
par(mfrow = c(1, 1)) # Returning the parameter to normal

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(i, RES_ACPA, RES_ACPJA, RES_ACPJF)
```

# Calculating the BLUPS

```{r}
# This loop will be calculating the BLUPS using the blups function defined at the beginning of the code file 

# Here we initialize the data frame where we will be adding the blups in the loop in the next line
BLUPSA <- data.frame()
BLUPSJA <- data.frame()
BLUPSJF <- data.frame()
for (i in 1:40) { # We will be calculating blups for the 40 axis of the PCA 
  bluA <- as.data.frame(blups(CO_ACPA[,i], CO_ACPA)) 
  bluJA <- as.data.frame(blups(CO_ACPJA[,i], CO_ACPJA))
  bluJF <- as.data.frame(blups(CO_ACPJF[,i], CO_ACPJF))
  # Naming all the columns as they were named before to be able to recognize them
  names(bluA)[4] <- names(CO_ACPA)[i]
  names(bluJA)[4] <- names(CO_ACPJA)[i]
  names(bluJF)[4] <- names(CO_ACPJF)[i]
  if ((nrow(BLUPSA) == 0) & (nrow(BLUPSJA) == 0) & (nrow(BLUPSJF) == 0)) { # Here we separate the first run of the loop from the others.In the fist run, the BLUPS data frame takes the value of the blups
    BLUPSA <- bluA[,3:4] 
    BLUPSJA <- bluJA[,3:4]
    BLUPSJF <- bluJF[,3:4]
  }else { # In the other cases, we merge the new values to the already existing data frame. They are merged because they are the same.
    BLUPSA <- merge(BLUPSA, bluA[,3:4], by.x = "grp", by.y = "grp")  
    BLUPSJA <- merge(BLUPSJA, bluJA[,3:4], by.x = "grp", by.y = "grp")
    BLUPSJF <- merge(BLUPSJF, bluJF[,3:4], by.x = "grp", by.y = "grp")
  }
}

# Here we take out the column that have null columns
BLUPSA <- BLUPSA[, -c(1 + which(apply(BLUPSA[2:41], 2, var) == 0))] 
BLUPSJA <- BLUPSJA[, -c(1 + which(apply(BLUPSJA[2:41], 2, var) == 0))]
BLUPSJF <- BLUPSJF[, -c(1 + which(apply(BLUPSJF[2:41], 2, var) == 0))]

# We name the first column EPO (up to here it represented the "group" by which it had been grouped in the loop)
names(BLUPSA)[1] <- "EPO"
names(BLUPSJA)[1] <- "EPO"
names(BLUPSJF)[1] <- "EPO"

# Saving the file of the acquired blups
save(BLUPSA, file = "BLUPSA_ACP.Rdata")
save(BLUPSJA, file = "BLUPSJA_ACP.Rdata")
save(BLUPSJF, file = "BLUPSJF_ACP.Rdata")

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(i, CO_ACPA, CO_ACPJA, CO_ACPJF, bluA, bluJA, bluJF)
```

# Analysis on the OTUs

## Making the data usable to do the analysis

```{r}
# Initializing the vectors that will be implemented with the heritability per OTU
OTU_HERI_ACPA <- c()
OTU_HERI_ACPJA <- c()
OTU_HERI_ACPJF <- c()

# Here we will make a histogram to take a look at the distribution of the squared cos of the PCA for each cluster/taxonomic group. As the column numbers are the same, we can do one loop considering the length of only one of the three tables.
par(mfrow = c(3,3)) # Defining parameter to have 5 graph windows
for (i in seq_along(1:ncol(ACPA$var$cos2))) {
  # Making a variable name to be able to recognize the plot
  nameA <- paste0("Distribution of the cos² \nfor cluster ", i, " in \ntable A") 
  nameJA <- paste0("Distribution of the cos² \nfor taxonomic group ", i, " in \ntable JA")
  nameJF <- paste0("Distribution of the cos² \nfor taxonomic group ", i, " in \ntable JF")
  
  # Plot of the column i in the considered table
  hist(ACPA$var$cos2[, i], main = nameA, xlab = "ACPA cos²") 
  hist(ACPJA$var$cos2[, i], main = nameJA, xlab = "ACPJA cos²")
  hist(ACPJF$var$cos2[, i], main = nameJF, xlab = "ACPJF cos²")
}
par(mfrow = c(1, 1)) # Returning the parameter to normal
dev.off() # Stopping the plotting process in the case the plots couldn't have been made. Otherwise, it blocks the process

# Here, we use the list defined before in the code to select only the axis that are heritable. This is used to select the As the three lists are different, we will do three separate loops
for (i in liste_axe_ACPA) {
  OTU_HERI_ACPA <- c(OTU_HERI_ACPA, which(ACPA$var$cos2[, i] > 1e-1)) # We only select the data for which there is a 10% correlation between the axis
}
for (i in liste_axe_ACPJA) {
  OTU_HERI_ACPJA <- c(OTU_HERI_ACPJA, which(ACPJA$var$cos2[, i] > 1e-1))
}
for (i in liste_axe_ACPJF) {
  OTU_HERI_ACPJF <- c(OTU_HERI_ACPJF, which(ACPJF$var$cos2[, i] > 1e-1))
}

# Eliminating all the double data in the OTU_HERI_ACP data set
OTU_HERI_ACPA <- unique(OTU_HERI_ACPA)
OTU_HERI_ACPJA <- unique(OTU_HERI_ACPJA)
OTU_HERI_ACPJF <- unique(OTU_HERI_ACPJF)

# Doing a PCA on the abundance of EPOs per cluster/taxonomic group taking into account only the heritable ones
ACPHA <- PCA(ABONDANCE_A[,OTU_HERI_ACPA], scale.unit = TRUE, ncp = 40, graph = TRUE)
ACPHJA <- PCA(ABONDANCE_JA[,OTU_HERI_ACPJA], scale.unit = TRUE, ncp = 40, graph = TRUE)
ACPHJF <- PCA(ABONDANCE_JF[,OTU_HERI_ACPJF], scale.unit = TRUE, ncp = 40, graph = TRUE)

# Plotting the results of the PCA
plot.PCA(ACPHA, aces = c(1, 2), choix = "ind", habillage = 13)
plot.PCA(ACPHJA, aces = c(1, 2), choix = "ind", habillage = 13)
plot.PCA(ACPHJF, aces = c(1, 2), choix = "ind", habillage = 13, xlim = c(-10,15))

# Extracting the coordinates of the heritable axis from the first PCA
CO_ACPHA <- as.data.frame(ACPHA$ind$coord)
CO_ACPHJA <- as.data.frame(ACPHJA$ind$coord)
CO_ACPHJF <- as.data.frame(ACPHJF$ind$coord)

# Renaming the row and columns to manipulate the data more easily
## Row names
CO_ACPHA$EPO <- sapply(strsplit(rownames(CO_ACPHA), "[.]"), "[", 2)
CO_ACPHA$BLOC <- sapply(strsplit(rownames(CO_ACPHA), "[.]"), "[", 3)
CO_ACPHJA$EPO <- sapply(strsplit(rownames(CO_ACPHJA), "[.]"), "[", 2)
CO_ACPHJA$BLOC <- sapply(strsplit(rownames(CO_ACPHJA), "[.]"), "[", 3)
CO_ACPHJF$EPO <- sapply(strsplit(rownames(CO_ACPHJF), "[.]"), "[", 2)
CO_ACPHJF$BLOC <- sapply(strsplit(rownames(CO_ACPHJF), "[.]"), "[", 3)
## Columns
names(CO_ACPHA)[1:40] <- paste0("D", 1:40)
names(CO_ACPHJA)[1:40] <- paste0("D", 1:40)
names(CO_ACPHJF)[1:15] <- paste0("D", 1:15)

# Calculating the genetic and environmental variances of the different axis of the PCA. We will do three loops because the three tables are not the same size
RES_ACPHA <- c()
for (i in 1:40) {
  RES_ACPHA <- c(RES_ACPHA, c(i, Hdeux(CO_ACPHA[, i], CO_ACPHA)))
}
RES_ACPHJA <- c()
for (i in 1:40) {
  RES_ACPHJA <- c(RES_ACPHJA, c(i, Hdeux(CO_ACPHJA[, i], CO_ACPHJA)))
}
RES_ACPHJF <- c()
for (i in 1:15) {
  RES_ACPHJF <- c(RES_ACPHJF, c(i, Hdeux(CO_ACPHJF[, i], CO_ACPHJF)))
}

# Transforming the tables into data frames that are more easily manipulable
RES_ACPHA <- as.data.frame(matrix(RES_ACPHA, ncol = 3, byrow = TRUE))
RES_ACPHJA <- as.data.frame(matrix(RES_ACPHJA, ncol = 3, byrow = TRUE))
RES_ACPHJF <- as.data.frame(matrix(RES_ACPHJF, ncol = 3, byrow = TRUE))
# Renaming the columns to be able to manipulate them more easily
names(RES_ACPHA) <- c("axe", "VG", "VE")
names(RES_ACPHJA) <- c("axe", "VG", "VE")
names(RES_ACPHJF) <- c("axe", "VG", "VE")

# Calculating the heritability of the PCA axis
RES_ACPHA$H2 <- RES_ACPHA$VG / (RES_ACPHA$VG + RES_ACPHA$VE)
RES_ACPHJA$H2 <- RES_ACPHJA$VG / (RES_ACPHJA$VG + RES_ACPHJA$VE)
RES_ACPHJF$H2 <- RES_ACPHJF$VG / (RES_ACPHJF$VG + RES_ACPHJF$VE)

# Plotting the heritability of the data
plot(1:40, RES_ACPHA$H2, xlab = "PCA axis", ylab = "Heritability")
plot(1:40, RES_ACPHJA$H2, xlab = "PCA axis", ylab = "Heritability")
plot(1:15, RES_ACPHJF$H2, xlab = "PCA axis", ylab = "Heritability") # The first axis may be very interesting to look at (H² > 0.8)

# Plotting the results of the PCA. We will do three different loops because the three data sets coming out of the PCA have different dimensions
par(mfrow = c(3, 2))
for (i in seq_along(1:40)) { # For table A
  boxplot(CO_ACPHA[, i] ~ CO_ACPHA$EPO,xlab = "EPOs", ylab = paste0("Coordinates of D", i)) # Plotting the coordinates of the EPOs on the different axis of the PCA
  hist(CO_ACPHA[, i], xlab = paste0("Coordinates of D", i), main = paste("Distribution of the coordinates of the EPOs on \naxis", i)) # Plotting the distribution of the coordinates of the EPOs on the different axis 
}
par(mfrow = c(1, 1)) # Returning the plot numbers to normal
# Doing the same thing for table JA
par(mfrow = c(3, 2))
for (i in seq_along(1:40)) {
  boxplot(CO_ACPHJA[, i] ~ CO_ACPHJA$EPO,xlab = "EPOs", ylab = paste0("Coordinates of D", i)) 
  hist(CO_ACPHJA[, i], xlab = paste0("Coordinates of D", i), main = paste("Distribution of the coordinates of the EPOs on \naxis", i)) 
}
par(mfrow = c(1, 1))
# Doing the same thing for table JF
par(mfrow = c(3, 2))
for (i in seq_along(1:15)) {
  boxplot(CO_ACPHJF[, i] ~ CO_ACPHJF$EPO,xlab = "EPOs", ylab = paste0("Coordinates of D", i)) 
  hist(CO_ACPHJF[, i], xlab = paste0("Coordinates of D", i), main = paste("Distribution of the coordinates of the EPOs on \naxis", i)) 
} # In this loop, the first axis is really nice to look at
par(mfrow = c(1, 1))

# Taking the variance of the coordinates to build a cladogram
COH_OTU_ACPHA <- ACPHA$var$coord
COH_OTU_ACPHJA <- ACPHJA$var$coord
COH_OTU_ACPHJF <- ACPHJF$var$coord

# To get an idea of the data we collected, we will give it a look (dimension and the beginning)
dim(COH_OTU_ACPHA)
head(COH_OTU_ACPHA)
dim(COH_OTU_ACPHJA)
head(COH_OTU_ACPHJA)
dim(COH_OTU_ACPHJF)
head(COH_OTU_ACPHJF)


# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(i, nameA, nameJA, nameJF, ACPA, ACPJA, ACPJF, ACPHA, ACPHJA,  ACPHJF, liste_axe_ACPA, liste_axe_ACPJA, liste_axe_ACPJF, CO_ACPHA, CO_ACPHJA, CO_ACPHJF, RES_ACPHA, RES_ACPHJA, RES_ACPHJF)
```

## Plotting the results depending on the OTUs

```{r}
# Making a clusterisation of the different clusters according to their variance in coordinates in the PCA
clustA <- hclust(dist(COH_OTU_ACPHA), method = "ward.D2")
plot(clustA)
clustJA <- hclust(dist(COH_OTU_ACPHJA), method = "ward.D2")
plot(clustJA)
clustJF <- hclust(dist(COH_OTU_ACPHJF), method = "ward.D2")
plot(clustJF)

# Taking out the samples that were selected up to now to have a look at the different levels of taxa that are present
MEMBRES_A <- cbind(A[OTU_HERI_ACPA,1:8],cutree(clustA, k = 2))
otu_id <- JA[OTU_HERI_ACPJA,]$otu_id
MEMBRES_JA <- cbind(otu_id, JA[OTU_HERI_ACPJA,1:6],cutree(clustJA, k = 3)) 
otu_id <- JF[OTU_HERI_ACPJF,]$otu_id
MEMBRES_JF <- cbind(otu_id, JF[OTU_HERI_ACPJF,1:7],cutree(clustJF, k = 3)) 
names(MEMBRES_A)[ncol(MEMBRES_A)] <- "groupe"
table(MEMBRES_A$groupe)
table(MEMBRES_A$Kingdom, MEMBRES_A$groupe)
table(paste(MEMBRES_A$Kingdom, MEMBRES_A$Phylum, sep="."), MEMBRES_A$groupe)
table(paste(MEMBRES_A$Kingdom, MEMBRES_A$Phylum, MEMBRES_A$Class, sep="."), MEMBRES_A$groupe)
table(paste(MEMBRES_A$Kingdom, MEMBRES_A$Phylum, MEMBRES_A$Class, MEMBRES_A$Order, sep="."), MEMBRES_A$groupe)
table(MEMBRES_A$Family, MEMBRES_A$groupe)
table(MEMBRES_A$Genus, MEMBRES_A$groupe)

# Same thing for table JA
names(MEMBRES_JA)[ncol(MEMBRES_JA)] <- "groupe"
table(MEMBRES_JA$groupe)
table(MEMBRES_JA$Kingdom, MEMBRES_JA$groupe)
table(paste(MEMBRES_JA$Kingdom, MEMBRES_JA$Phylum, sep="."), MEMBRES_JA$groupe)
table(MEMBRES_JA$Class, MEMBRES_JA$groupe)  # Rajouter les actinobacter
table(MEMBRES_JA$Order, MEMBRES_JA$groupe)
table(MEMBRES_JA$Family, MEMBRES_JA$groupe)
table(MEMBRES_JA$Genus, MEMBRES_JA$groupe)

# Same thing for table JF
names(MEMBRES_JF)[ncol(MEMBRES_JF)] <- "groupe"
table(MEMBRES_JF$groupe)
table(MEMBRES_JF$Kingdom, MEMBRES_JF$groupe)
table(paste(MEMBRES_JF$Kingdom, MEMBRES_JF$Phylum, sep="."), MEMBRES_JF$groupe)
table(MEMBRES_JF$Class, MEMBRES_JF$groupe)
table(MEMBRES_JF$Order, MEMBRES_JF$groupe)
table(MEMBRES_JF$Family, MEMBRES_JF$groupe)
table(MEMBRES_JF$Genus, MEMBRES_JF$groupe)

# Making labels for the dendrogram The three levels are different because we have only one Kingdom level in table B so, it is less interesting to plot this whereas it is more interesting to illustrate the diversity here
labeulsA <- A[OTU_HERI_ACPA, "Kingdom"]
labeulsJA <- JA[OTU_HERI_ACPJA, "Class"]
labeulsJF <- JF[OTU_HERI_ACPJF, "Class"]

# Defining colours depending on the level of taxonomy (in the same way as before, it depends on the diversity we want to illustrate so three different levels of classification are kept)
## Making a factor vector with all the taxa depending on the level of study.
colorA <- as.factor(A[OTU_HERI_ACPA, "Phylum"])
colorJA <- as.factor(JA[OTU_HERI_ACPJA, "Order"])
colorJF <- as.factor(JF[OTU_HERI_ACPJF, "Order"])
## Defining as many colours as there is levels in the colour vector and transforming it back to characters to use them later on
levels(colorA) <- viridis(nlevels(colorA))
levels(colorJA) <- viridis(nlevels(colorJA)) 
levels(colorJF) <- viridis(nlevels(colorJF)) 
colorA <- as.character(colorA)
colorJA <- as.character(colorJA)
colorJF <- as.character(colorJF)

# Transforming the cladograms into dendrograms and giving the branches a colour plus adding the coloured labels
dendA <- as.dendrogram(clustA) %>% 
  color_branches(5, col = c(1:5)) %>% 
  set("labels", labeulsA) %>% 
  set("labels_colors", colorA) %>% 
  set("labels_cex", rep(0.3, nrow(COH_OTU_ACPHA))) %>% 
  plot()
dendJA <- as.dendrogram(clustJA) %>% 
  color_branches(3, col = c(1:3)) %>% 
  set("labels", labeulsJA) %>% 
  set("labels_colors", colorJA) %>% 
  set("labels_cex", rep(0.3, nrow(COH_OTU_ACPHJA))) %>% 
  plot()
dendJF <- as.dendrogram(clustJF) %>% 
  color_branches(3, col = c(1:3)) %>% 
  set("labels", labeulsJF) %>% 
  set("labels_colors", colorJF) %>% 
  set("labels_cex", rep(0.3, nrow(COH_OTU_ACPHJF))) %>% 
  plot()

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(otu_id, clustA, clustJA, clustJF, colorA, colorJA, colorJF, labeulsA, labeulsJA, labeulsJF, COH_OTU_ACPHA, COH_OTU_ACPHJA, COH_OTU_ACPHJF, MEMBRES_A, MEMBRES_JA, MEMBRES_JF, OTU_HERI_ACPA, OTU_HERI_ACPJA, OTU_HERI_ACPJF, dendA, dendJA, dendJF)
```

## Calculating the heredity per OTU

```{r}
# Transforming the abundance matrixes into data frames
ABONDANCE_A <- as.data.frame(ABONDANCE_A)
ABONDANCE_JA <- as.data.frame(ABONDANCE_JA)
ABONDANCE_JF <- as.data.frame(ABONDANCE_JF)

# Adding an EPO and a Bloc column in the data frames
ABONDANCE_A$EPO <- sapply(strsplit(rownames(ABONDANCE_A), "[.]"), "[", 2)
ABONDANCE_A$BLOC <- sapply(strsplit(rownames(ABONDANCE_A), "[.]"), "[", 3)
ABONDANCE_JA$EPO <- sapply(strsplit(rownames(ABONDANCE_JA), "[.]"), "[", 2)
ABONDANCE_JA$BLOC <- sapply(strsplit(rownames(ABONDANCE_JA), "[.]"), "[", 3)
ABONDANCE_JF$EPO <- sapply(strsplit(rownames(ABONDANCE_JF), "[.]"), "[", 2)
ABONDANCE_JF$BLOC <- sapply(strsplit(rownames(ABONDANCE_JF), "[.]"), "[", 3)

# Calculating the variance in the three data frames using the Hdeux function defined before. The number of columns of the three data frames are different so we will apply three loops
RES_OTUA <- c()
for (i in seq_along(1:(ncol(ABONDANCE_A)-1))) {
  RES_OTUA <- c(RES_OTUA, c(i, as.numeric(Hdeux(ABONDANCE_A[,i], ABONDANCE_A)))) 
}
RES_OTUJA <- c()
for (i in seq_along(1:(ncol(ABONDANCE_JA)-1))) {
  RES_OTUJA <- c(RES_OTUJA, c(i, Hdeux(ABONDANCE_JA[,i], ABONDANCE_JA))) 
}
RES_OTUJF <- c()
for (i in seq_along(1:(ncol(ABONDANCE_JF)-1))) {
  RES_OTUJF <- c(RES_OTUJF, c(i, Hdeux(ABONDANCE_JF[,i], ABONDANCE_JF))) 
}

# Transforming the resulting vector into a data frame and renaming the columns to manipulate them more easily all the data
RES_OTUA <- as.data.frame(matrix(RES_OTUA, ncol = 3, byrow = TRUE))
RES_OTUJA <- as.data.frame(matrix(RES_OTUJA, ncol = 3, byrow = TRUE))
RES_OTUJF <- as.data.frame(matrix(RES_OTUJF, ncol = 3, byrow = TRUE))
names(RES_OTUA) <- c("axe", "VG", "VE")
names(RES_OTUJA) <- c("axe", "VG", "VE")
names(RES_OTUJF) <- c("axe", "VG", "VE")

# Calculating the heritability and adding them to the data frames
RES_OTUA$H2 <- RES_OTUA$VG / (RES_OTUA$VG + RES_OTUA$VE)
RES_OTUJA$H2 <- RES_OTUJA$VG / (RES_OTUJA$VG + RES_OTUJA$VE)
RES_OTUJF$H2 <- RES_OTUJF$VG / (RES_OTUJF$VG + RES_OTUJF$VE)

# Calculating the mean of the abundance of reads on each EPO per cluster/taxonomic levels
moyenneA <- apply(ABONDANCE_A[,1:(ncol(ABONDANCE_A)-2)], 2, mean)
moyenneJA <- apply(ABONDANCE_JA[,1:(ncol(ABONDANCE_JA)-2)], 2, mean)
moyenneJF <- apply(ABONDANCE_JF[,1:(ncol(ABONDANCE_JF)-2)], 2, mean)

# Plotting the heritability of the data in the abundance tables and their distribution
par(mfrow = c(1,2))
plot(RES_OTUA$H2)
hist(RES_OTUA$H2)
plot(RES_OTUJA$H2)
hist(RES_OTUJA$H2)
plot(RES_OTUJF$H2)
hist(RES_OTUJF$H2)
par(mfrow = c(1,1))

# Plotting the heritability of the abundance depending on the mean of the abundance 
par(mfrow = c(3,1))
plot(log10(moyenneA), RES_OTUA$H2)
plot(log10(moyenneJA), RES_OTUJA$H2)
plot(log10(moyenneJF), RES_OTUJF$H2)
par(mfrow = c(1,1))

# Calculating a list of the clusters/taxonomic groups in which the heritability is superior to 0.4
liste_otuA <- which(RES_OTUA$H2>0.4)   
liste_otuJA <- which(RES_OTUJA$H2>0.4)
liste_otuJF <- which(RES_OTUJF$H2>0.4)
# Selecting these clusters/taxonomic groups
RES_OTUA[liste_otuA,]
RES_OTUJA[liste_otuJA,]
RES_OTUJF[liste_otuJF,]

# Plotting separately the abundance of the clusters/taxonomic groups depending on the EPOs for the three tables
par(mfrow = c(3,3))
for (i in liste_otuA) {
  boxplot(ABONDANCE_A[,i] ~ ABONDANCE_A$EPO)
}
par(mfrow = c(1,1))
par(mfrow = c(3,3))
for (i in liste_otuJA) {
  boxplot(ABONDANCE_JA[,i] ~ ABONDANCE_JA$EPO)
}
par(mfrow = c(1,1))
par(mfrow = c(3,3))
for (i in liste_otuJF) {
  boxplot(ABONDANCE_JF[,i] ~ ABONDANCE_JF$EPO)
}
par(mfrow = c(1,1))
# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(i, moyenneA, moyenneJA, moyenneJF, ABONDANCE_A, ABONDANCE_JA, ABONDANCE_JF, RES_OTUA, RES_OTUJA, RES_OTUJF)
```

# AFC analysis on the coordinates

## Analysis

```{r}
# Plotting the histogram of the sums of reads per EPO to get an idea of the distribution of the data
par(mfrow = c(3, 1))
hist(sommeA)
hist(sommeJA)
hist(sommeJF)
par(mfrow = c(1, 1))

# Getting the dimensions of the S tables to know what we are working with
dim(SA)
dim(SJA)
dim(SJF)

# Doing a correspondence analysis on the S tables to extract the coordinates
res.caA = CA(SA, ncp = 40) # Two clusters are out of the data cloud
res.caJA = CA(SJA, ncp = 40)
res.caJF = CA(SJF, ncp = 40) # Same, one cluster and one EPO are out of the cloud

# Sans les deux individus éliminés ça améliore de beaucoup les représentations
COA <- res.caA$col$coord
COJA <- res.caJA$col$coord
COJF <- res.caJF$col$coord

dim(COA)
rownames(COA)
dim(COJA)
rownames(COJA)
dim(COJF)
rownames(COJF)

# Il y a deux données bizarres mais pas quand elles sont éliminées

# lignes qui nous ont servi à identifier les ratons laveurs
# which(CO[,1]==max(CO[,1]))
# somme[which(CO[,1]==max(CO[,1]))]

# which(CO[,2]==max(CO[,2]))
# somme[which(CO[,2]==max(CO[,2]))]

par(mfrow = c(3, 3))
for (i in seq_along(1:ncol(COA))) {
  hist(COA[,i])
  hist(COJA[,i])
  hist(COJF[,i])
}
plot(COA[,1], COA[,2])
plot(COJA[,1], COJA[,2])
plot(COJF[,1], COJF[,2])
par(mfrow = c(1, 1))


# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(i, sommeA, sommeJA, sommeJF, liste_otuA, liste_otuJA, liste_otuJF)
```

## Heritability

```{r}
# Transforming into a data frame to manipulate them more easily
COA <- as.data.frame(COA)
COJA <- as.data.frame(COJA)
COJF <- as.data.frame(COJF)
# Adding an EPO and a BLoc column to the data frames
COA$EPO<-  sapply(strsplit(rownames(COA),"[.]"),"[",2)
COA$BLOC<-sapply(strsplit(rownames(COA),"[.]"),"[",3)
COJA$EPO<-  sapply(strsplit(rownames(COJA),"[.]"),"[",2)
COJA$BLOC<-sapply(strsplit(rownames(COJA),"[.]"),"[",3)
COJF$EPO<-  sapply(strsplit(rownames(COJF),"[.]"),"[",2)
COJF$BLOC<-sapply(strsplit(rownames(COJF),"[.]"),"[",3)
# Renaming the columns coming out of the analysis
names(COA)[1:40] <- paste0("D", 1:40)
names(COJA)[1:40] <- paste0("D", 1:40)
names(COJF)[1:40] <- paste0("D", 1:40)

# Calculating the variances of each axis
RESA <- c()
RESJA <- c()
RESJF <- c()
for (i in 1:40) {
  RESA <- c(RESA, c(i, Hdeux(COA[,i], COA)))
  RESJA <- c(RESJA, c(i, Hdeux(COJA[,i], COJA)))
  RESJF <- c(RESJF, c(i, Hdeux(COJF[,i], COJF)))
}

# Transforming the data frames containing the variances 
RESA <- as.data.frame(matrix(RESA, ncol = 3, byrow = TRUE))
RESJA <- as.data.frame(matrix(RESJA, ncol = 3, byrow = TRUE))
RESJF <- as.data.frame(matrix(RESJF, ncol = 3, byrow = TRUE))
# Renaming the axis
names(RESA) <- c("axe", "VG", "VE")
names(RESJA) <- c("axe", "VG", "VE")
names(RESJF) <- c("axe", "VG", "VE")

# calculating the heritability of the data frames
RESA$H2 <- RESA$VG / (RESA$VG +RESA$VE)
RESJA$H2 <- RESJA$VG / (RESJA$VG +RESJA$VE)
RESJF$H2 <- RESJF$VG / (RESJF$VG +RESJF$VE)

# Plotting the obtained heritabilities
plot(1:40, RESA$H2)
plot(1:40, RESJA$H2)
plot(1:40, RESJF$H2) # The numbers 6 and 12 are really interesting (H² > 0.5)

# Making a list of the axis that are the mot heritable in the analysis
liste_axesA <- which(RESA$H2 >= 0)
liste_axesJA <- which(RESJA$H2 >= 0)
liste_axesJF <- which(RESJF$H2 >= 0)

# Keeping the clusters/taxonomic groups from the list designed before and for which the cos² is superior to 1%
OTU_HERIA <- c()
for (i in liste_axesA) {
  OTU_HERIA <- c(OTU_HERIA, which(res.caA$row$cos2[, i] > 1e-1))
}
OTU_HERIJA <- c()
for (i in liste_axesJA) {
  OTU_HERIJA <- c(OTU_HERIJA, which(res.caJA$row$cos2[, i] > 1e-1))
}
OTU_HERIJF <- c()
for (i in liste_axesJF) {
  OTU_HERIJF <- c(OTU_HERIJF, which(res.caJF$row$cos2[, i] > 1e-1))
}

# Sorting the data to make sure we only have one of each selected cluster/taxonomic group
OTU_HERIA <- unique(OTU_HERIA)
OTU_HERIJA <- unique(OTU_HERIJA)
OTU_HERIJF <- unique(OTU_HERIJF)

# Selecting in the S tables the clusters/taxonomic groups that we chose at the end of the AFC
SAHA <- SA[OTU_HERIA, ]
SAHJA <- SJA[OTU_HERIJA, ] %>% 
  slice(-c(101, 103, 104)) # These points come out a lot in the CA coming in  the next steps
SAHJF <- as.data.frame(SJF[OTU_HERIJF, ]) %>% 
  slice(-c(11, 14, 24))  # These points come out a lot in the CA coming in  the next steps

# Making a second analysis on the results of the first analysis
res.caHA <- CA(SAHA, ncp = 40)
# plot_ly(as.data.frame(res.caHA)) # This doesn't work and I don't know how tu use it
res.caHJA <- CA(SAHJA, ncp = 40) # Cluster_80 is out of range ...
res.caHJF <- CA(SAHJF, ncp = 40) # Clusters 66 and 196 are way out of the cloud

# Extracting the coordinates of the analysis and transforming them into a data frame to be able to manipulate them more easily
COHA <- as.data.frame(res.caHA$col$coord)
COHJA <- as.data.frame(res.caHJA$col$coord)
COHJF <- as.data.frame(res.caHJF$col$coord)

# Plotting the distributions of the coordinates of the different tables
par(mfrow = c(3, 2))
for (i in 1:ncol(COHA)) {
  hist(COHA[, i])
  hist(COHJA[, i])
}
par(mfrow = c(1, 1))
par(mfrow = c(3, 3))
for (i in 1: ncol(COHJF)) {
  hist(COHJF[, i])
}
par(mfrow = c(1, 1))

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(COA, COJA, COJF, RESA, RESJA, RESJF, SA, SJA, SJF, liste_axesA, liste_axesJA, liste_axesJF, res.caA, res.caJA, res.caJF, SAHA, SAHJA, SAHJF)

```

## Heritability

```{r}
# Adding the Bloc and EPO columns in the end of the table
COHA$EPO<-  sapply(strsplit(rownames(COHA),"[.]"),"[",2)
COHA$BLOC<-sapply(strsplit(rownames(COHA),"[.]"),"[",3)
COHJA$EPO<-  sapply(strsplit(rownames(COHJA),"[.]"),"[",2)
COHJA$BLOC<-sapply(strsplit(rownames(COHJA),"[.]"),"[",3)
COHJF$EPO<-  sapply(strsplit(rownames(COHJF),"[.]"),"[",2)
COHJF$BLOC<-sapply(strsplit(rownames(COHJF),"[.]"),"[",3)
# Renaming the axis so they are easier to manipulate
names(COHA)[1:40] <- paste0("D", 1:40)
names(COHJA)[1:40] <- paste0("D", 1:40)
names(COHJF)[1:40] <- paste0("D", 1:40)

# Initialising the loop to calculate the genetic and enironmental variances of the axis of the analysis. As the three tables don't have the same size, we will do two loops
RESHA <- c()
RESHJA <- c()
RESHJF <- c()
for (i in 1:40) {
  RESHA <- c(RESHA, c(i, Hdeux(COHA[, i], COHA))) 
  RESHJA <- c(RESHJA, c(i, Hdeux(COHJA[, i], COHJA)))
}
for (i in 1:40) {
    RESHJF <- c(RESHJF, c(i, Hdeux(COHJF[, i], COHJF)))
}

# Making the obtained variances into data frames and renaming the axis for easier manipulation
RESHA <- as.data.frame(matrix(RESHA, ncol = 3, byrow = TRUE))
RESHJA <- as.data.frame(matrix(RESHJA, ncol = 3, byrow = TRUE))
RESHJF <- as.data.frame(matrix(RESHJF, ncol = 3, byrow = TRUE))
names(RESHA) <- c("axe", "VG", "VE")
names(RESHJA) <- c("axe", "VG", "VE")
names(RESHJF) <- c("axe", "VG", "VE")

# Calculating the heritability of the axis
RESHA$H2 <- RESHA$VG / (RESHA$VG + RESHA$VE)
RESHJA$H2 <- RESHJA$VG / (RESHJA$VG + RESHJA$VE)
RESHJF$H2 <- RESHJF$VG / (RESHJF$VG + RESHJF$VE)

# Plotting the heritabilities
plot(1:40, RESHA$H2)
plot(1:40, RESHJA$H2)
plot(1:40, RESHJF$H2)

# Extracting the coordinates of the clusters/taxonomic groups 
COH_OTUA <- res.caHA$row$coord
COH_OTUJA <- res.caHJA$row$coord
COH_OTUJF <- res.caHJF$row$coord

# Clustering the clusters/taxonomic groups depending on the ward.D2 distance on the calculated coordinates of the analysis
clustA <- hclust(dist(COH_OTUA), method = "ward.D2")
plot(clustA)
clustJA <- hclust(dist(COH_OTUJA), method = "ward.D2")
plot(clustJA)
clustJF <- hclust(dist(COH_OTUJF), method = "ward.D2")
plot(clustJF)

# Making labels for the plotting of the clusterisation rather than to use the number of the cluster
labeulsA <- A[OTU_HERIA, "Family"]
labeulsJA <- A[OTU_HERIJA, "Family"]
labeulsJF <- A[OTU_HERIJF, "Family"]

MEMBRESA <- cbind(A[OTU_HERIA, 1:8], cutree(clustA, k = 4))
names(MEMBRESA)[ncol(MEMBRESA)] <- "groupe"
table(MEMBRESA$groupe)
table(MEMBRESA$Kingdom, MEMBRESA$groupe)
table(paste(MEMBRESA$Kingdom,MEMBRESA$Phylum,sep="."), MEMBRESA$groupe)
table(MEMBRESA$Class, MEMBRESA$groupe)
table(MEMBRESA$Order, MEMBRESA$groupe)
table(MEMBRESA$Family, MEMBRESA$groupe)
table(MEMBRESA$Genus, MEMBRESA$groupe)


MEMBRESJA <- cbind(JA[OTU_HERIJA, 1:6] %>% 
                     slice(-c(11, 14, 24)), 
                   cutree(clustJA, k = 3))
names(MEMBRESJA)[ncol(MEMBRESJA)] <- "groupe"
table(MEMBRESJA$groupe)
table(MEMBRESJA$Kingdom, MEMBRESJA$groupe)
table(paste(MEMBRESJA$Kingdom,MEMBRESJA$Phylum,sep="."), MEMBRESJA$groupe)
table(MEMBRESJA$Class, MEMBRESJA$groupe)
table(MEMBRESJA$Order, MEMBRESJA$groupe)
table(MEMBRESJA$Family, MEMBRESJA$groupe)
table(MEMBRESJA$Genus, MEMBRESJA$groupe)


MEMBRESJF <- cbind(JF[OTU_HERIJF, 1:7] %>% 
                     slice(-c(11, 14, 24)), 
                   cutree(clustJF, k = 2))
names(MEMBRESJF)[ncol(MEMBRESJF)] <- "groupe"
table(MEMBRESJF$groupe)
table(MEMBRESJF$Kingdom, MEMBRESJF$groupe)
table(paste(MEMBRESJF$Kingdom,MEMBRESJF$Phylum,sep="."), MEMBRESJF$groupe)
table(MEMBRESJF$Class, MEMBRESJF$groupe)
table(MEMBRESJF$Order, MEMBRESJF$groupe)
table(MEMBRESJF$Family, MEMBRESJF$groupe)
table(MEMBRESJF$Genus, MEMBRESJF$groupe)

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(i, MEMBRESA, MEMBRESJA, MEMBRESJF, COHA, COHJA, COHJF, res.caHA, res.caHJA, res.caHJF, RESHA, RESHJA, RESHJF)
```

## Plotting the results with colours

```{r}
# Making colour labels for the stems in the dendrogram
colorA <- as.factor(A[OTU_HERIA, "Phylum"])
colorJA <- as.factor(JA[OTU_HERIJA, "Phylum"])
colorJF <- as.factor(JF[OTU_HERIJF, "Phylum"])
levels(colorA) <- viridis(nlevels(colorA))
levels(colorJA) <- viridis(nlevels(colorJA))
levels(colorJF) <- viridis(nlevels(colorJF))
colorA <- as.character(colorA)
colorJA <- as.character(colorJA)
colorJF <- as.character(colorJF)

# Transforming the cladograms into dendrograms and plotting the dendrograms
dendA <- clustA %>%
  as.dendrogram() %>% 
  color_branches(4, col = c(1:4)) %>% 
  set("labels", labeulsA) %>%
  set("labels_color", colorA) %>%
  set("labels_cex", rep(0.3,nrow(COH_OTUA))) %>%
  plot()
dendJA <- clustJA %>% 
  as.dendrogram() %>% 
  color_branches(5, col = c(1:5)) %>%
  set("labels", labeulsJA) %>%
  set("labels_color", colorJA) %>%
  set("labels_cex", rep(0.3,nrow(COH_OTUJA))) %>%
  plot()
dendJF <- clustJF %>% 
  as.dendrogram() %>% 
  color_branches(8, col = c(1:8)) %>%
  set("labels", labeulsJF) %>%
  set("labels_color", colorJF) %>%
  set("labels_cex", rep(0.3,nrow(COH_OTUJF))) %>%
  plot()

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(dendA, dendJA, dendJF, labeulsA, labeulsJA, labeulsJF, colorA, colorJA, colorJF, OTU_HERIA, OTU_HERIJA, OTU_HERIJF, COH_OTUA, COH_OTUJA, COH_OTUJF, clustA, clustJA, clustJF)
```

# GWAS

## Genotypes

### Position of SNPs

Loading the file containing all the positions of the SNPs on the wheat genome
```{r}
file <- load("C:/Documents/ECOLE/2021-2022 Montpellier SupAgro/Stage/Stage 2A et césure/Stage CBGP - ARCAD/Données/Jacques/Jacques_project_bacteria/BREEDWHEAT_on_durum_physic_Svevo1.Rdata")
dim(BLAST)
```

### Genotyping matrix

Loading the correspondence table of the EPOs containing the different SNPs
```{r}
# Breed wheat genotypes
SG <- as.data.frame(data.table::fread("C:/Documents/ECOLE/2021-2022 Montpellier SupAgro/Stage/Stage 2A et césure/Stage CBGP - ARCAD/Données/Jacques/Jacques_project_bacteria/SG_EPO_complet.csv"))

# Renaming the rows using the names of the EPOs
rownames(SG) <- as.character(SG[, 1])
# Once the row names are given, we can remove the first column that does not serve any purpose
SG <- SG %>% 
  select(-V1)
# Getting the dimensions of the SG table
dim(SG)
```

### Filtering the genotyping matrix

```{r}
# Keeping the SNPs that have an assumed physical position (this part is optional)
liste <- which(colnames(SG) %in% BLAST[, 1])
length(liste) # Getting the number of SNPs that have an assumed physical position
SG <- SG[, liste] # Extracting the previously selected SNPs
dim(SG) # Getting the new dimensions of the SG table

# Taking this genotype out because it causes problems in the next part of the data filtering process
SG <- SG[- which(rownames(SG)=="TT04DD79_27"), ]

# Making a list of the numbers corresponding to each EPOs
liste_geno <- sapply(strsplit(rownames(SG), "_"), "[", 2) 
# Extracting the selected genotypes in the previous step from the blups matrix
SGA <- SG[which(liste_geno %in% as.character(BLUPSA$EPO)), ]
SGJA <- SG[which(liste_geno %in% as.character(BLUPSJA$EPO)), ]
SGJF <- SG[which(liste_geno %in% as.character(BLUPSJF$EPO)), ]
# Renaming the rows with the numbers
rownames(SGA) <- sapply(strsplit(rownames(SGA), "_"), "[", 2)
rownames(SGJA) <- sapply(strsplit(rownames(SGJA), "_"), "[", 2)
rownames(SGJF) <- sapply(strsplit(rownames(SGJF), "_"), "[", 2)


# Making new data frames to use in the next steps
genotA <- (SGA)
genotJA <- (SGJA)
genotJF <- (SGJF)
# Taking into account the dimensions of the genot tables
dim(genotA)
dim(genotJA)
dim(genotJF)

# Keeping the names of the rows in a separate variable to rename the rows without loosing this metadata for the next step
nomsA <- rownames(genotA)
nomsJA <- rownames(genotJA)
nomsJF <- rownames(genotJF)
# Transforming all the columns in the genotype data as numeric data
genotA <- apply(genotA, 2, as.numeric)
genotJA <- apply(genotJA, 2, as.numeric)
genotJF <- apply(genotJF, 2, as.numeric)
# Re attributing the kept names in the temporary variable
rownames(genotA) <- nomsA
rownames(genotJA) <- nomsJA
rownames(genotJF) <- nomsJF

# Transforming the tables to matrices to manipulate more quickly
genotA <- as.matrix(genotA)
genotJA <- as.matrix(genotJA)
genotJF <- as.matrix(genotJF)

# Taking out the NA values obtained in the contingency tables that are made with the NAsout function defined in the beginning of the script
genot.impA <- apply(genotA, 2, NAsout)
genot.impJA <- apply(genotJA, 2, NAsout)
genot.impJF <- apply(genotJF, 2, NAsout)

# Calculating the allelic frequencies of the three tables
pA <- colMeans(genot.impA) / 2
pJA <- colMeans(genot.impJA) / 2
pJF <- colMeans(genot.impJF) / 2
qA <- 1 - pA
qJA <- 1 - pJA
qJF <- 1 - pJF

# Taking the minimum of the p and q corresponding to each genotype
mafA <- apply(cbind(pA,qA), 1, min) 
mafJA <- apply(cbind(pJA,qJA), 1, min)
mafJF <- apply(cbind(pJF,qJF), 1, min)

# Plotting the distribution of the minimal allelic frequencies
par(mfrow = c(3, 1))
hist(mafA, col = "grey", main = "Distribution of the minimal allelic frequencies from table A", breaks = 50, xlim = c(0,0.5))
hist(mafJA, col = "grey", main = "Distribution of the minimal allelic frequencies from table JA", breaks = 50, xlim = c(0,0.5))
hist(mafJF, col = "grey", main = "Distribution of the minimal allelic frequencies from table JF", breaks = 50, xlim = c(0,0.5))
par(mfrow = c(1, 1))

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(pA, pJA, pJF, qA, qJA, qJF, nomsA, nomsJA, nomsJF, liste, liste_geno, genotA, genotJA, genotJF, SG, SGA, SGJA, SGJF)
```

### Applying a filter thanks to the allelic frequencies
 
```{r maf filter}
# Filtering the genot table to conserve only the allelic frequencies superior to 0.05
genot.okA <- genot.impA[, mafA >= 0.05]
genot.okJA <- genot.impJA[, mafJA >= 0.05]
genot.okJF <- genot.impJF[, mafJF >= 0.05]
```

### Making a physical map of the placement of the SNPs for the EPOs

```{r import map}
# Making the physical map by filtering the columns in the BLAST table. We are keeping the columns that are selected beforehand 
mapA <- BLAST[which(BLAST[, 1] %in% colnames(genot.okA)), c(1, 2, 6)]
mapJA <- BLAST[which(BLAST[, 1] %in% colnames(genot.okJA)), c(1, 2, 6)]
mapJF <- BLAST[which(BLAST[, 1] %in% colnames(genot.okJF)), c(1, 2, 6)]

# Renaming the columns of the map
names(mapA) <- c("SNP", "Chr", "Pos")
names(mapJA) <- c("SNP", "Chr", "Pos")
names(mapJF) <- c("SNP", "Chr", "Pos")

# Looking at the dimensions of the maps
dim(mapA)
dim(mapJA)
dim(mapJF)
# Looking at the class of the maps
class(mapA)
class(mapJA)
class(mapJF)
```


### Filtering the conserved SNPs

```{r}
# Filtering the data in the map to be the same as the one in the genotyping matrix
mapA <- mapA[mapA$SNP %in% colnames(genot.okA), ]
mapJA <- mapJA[mapJA$SNP %in% colnames(genot.okJA), ]
mapJF <- mapJF[mapJF$SNP %in% colnames(genot.okJF), ]
# Turning the chromosome column into numeric data
mapA[,3]<-as.numeric(mapA[,3])
mapJA[,3]<-as.numeric(mapJA[,3])
mapJF[,3]<-as.numeric(mapJF[,3])
```


### Sorting by chromosome and position

```{r map sort}
# Sorting the data in the tables by the position of the SNP and by chromosome to make the map for the manhattan plot in the next steps
mapA <- mapA %>% 
  arrange(Pos, .by_group = TRUE) %>% 
  arrange(Chr, .by_group = TRUE)
mapJA <- mapJA %>% 
  arrange(Pos, .by_group = TRUE) %>% 
  arrange(Chr, .by_group = TRUE)
mapJF <- mapJF %>% 
  arrange(Pos, .by_group = TRUE) %>% 
  arrange(Chr, .by_group = TRUE)

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(genot.impA, genot.impJA, genot.impJF, mafA, mafJA, mafJF)
```

## Choosing the variable to analyse and preparing the phenotype vector

The important variable is placed into the y variable

```{r import phenot}
# Changing the row names according to the EPO we are working on and taking out the EPO column of the BLUPS data to be able to work on the axis' data
BLUPSA <- BLUPSA %>%
  column_to_rownames("EPO")
BLUPSJA <- BLUPSJA %>% 
  column_to_rownames("EPO")
BLUPSJF <- BLUPSJF %>% 
  column_to_rownames("EPO")
```

## Calculating the Kinship matrix

```{r plot match, fig.height = 4.5, fig.width = 4.5}
# Calculating the allelic frequencies
pA <- colMeans(genot.okA) / 2
pJA <- colMeans(genot.okJA) / 2
pJF <- colMeans(genot.okJF) / 2
qA <- 1 - pA
qJA <- 1 - pJA
qJF <- 1 - pJF

# Calculating a Van Raden scaled genotype
genot.scaledA <- scale(genot.okA, center = 2 * pA, scale = sqrt(2 * pA * qA))
genot.scaledJA <- scale(genot.okJA, center = 2 * pJA, scale = sqrt(2 * pJA * qJA))
genot.scaledJF <- scale(genot.okJF, center = 2 * pJF, scale = sqrt(2 * pJF * qJF))

KA <- tcrossprod(genot.scaledA) / ncol(genot.scaledA)
KA <- lqmm::make.positive.definite(KA)
KJA <- tcrossprod(genot.scaledJA) / ncol(genot.scaledJA)
KJA <- lqmm::make.positive.definite(KJA)
KJF <- tcrossprod(genot.scaledJF) / ncol(genot.scaledJF)
KJF <- lqmm::make.positive.definite(KJF)

par(mfrow = c(3, 1))
hist(KA)
hist(KJA)
hist(KJF)
par(mfrow = c(1, 1))

# Looking at the dimensions of the genotype tables
dim(genot.scaledA)
dim(genot.scaledJA)
dim(genot.scaledJF)
# Doing the same with the Kinship matrices
dim(KA)
dim(KJA)
dim(KJF)

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
rm(pA, pJA, pJF, qA, qJA, qJF)
```

## Doing the GWAS for all the BLUPS and all the filtering techniques

### GWAS for all the BLUPS of table A

```{r manhattan plot}
for (i in 1:ncol(BLUPSA)) {
  # Verification to see if i is becoming bigger at each loop
  print(i)
  # Attribution of the BLUPS column i to a variable that we will be using here
  y <- BLUPSA[, i]
  # Taking the rownames
  names(y) <- rownames(BLUPSA)
  # Suppressing the number 102 that fabricates some mistakes in the plots
  y <- y[-102]
  
  # Ordering the two vectors so that they are in the same order
  genot.ok <- genot.okA[order(rownames(genot.okA)), ]
  y <- y[order(names(y))]

  genot.loop <- genot.ok

  #  Taking out the possible missing values in the y vector if there are any
  if (length(which(is.na(y))) > 0) {
    liste <- which(is.na(y))
    y <- y[ - liste, ]
  }
  # Sorting out the markers to have all the ones that are present on the map. Do not execute this line to have all the markers
  genot.loop <- genot.loop[, mapA$SNP]
  # Calculating allelic frequencies
  p <- colMeans(genot.loop) / 2
  q <- 1 - p
  # Scaling the genotype matrix using a Van Raden method
  genot.scaled <- scale(genot.loop, center = 2 * p, scale = sqrt(2 * p * q))
  # With the thresh : we select the best model which is a little bit less conservative that the Benferroni model
  res_mlmm <- mlmm_allmodels(y, list(genot.scaled), list(KA), maxsteps = 4, threshold=1e-4)
  # Making a Manhattan plot of the mixed model used before
  manhatt <- mlmm.gwas::manhattan.plot(res_mlmm, map = mapA, steps = 1, hideCofactors = FALSE, chrToPlot = "all", unit = "bp", main = paste("Plot for axis", names(BLUPSA)[i], "on table A"))
  # Printing it with a line showing the threshold to determine where to stop
  manhatt
  abline(h = 5, col = "red", lwd = 2)
  # Saving the graph
  dev.print(device = png, file = paste0("table_A/ACP/Axes_bruts/Manhattan plot of the p-values for all markers on the axis ",  names(BLUPSA)[i], " of the AFC for table A.png"), width = 1800)
}

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
```

Axes qui ont un QTL - D10; D21

### GWAS for all the BLUPS of table JA

```{r manhattan plot}
for (i in 1:ncol(BLUPSJA)) {
  # Verification to see if i is becoming bigger at each loop
  print(i)
  # Attribution of the BLUPS column i to a variable that we will be using here
  y <- BLUPSJA[, i]
  # Taking the rownames
  names(y) <- rownames(BLUPSJA)
  # Suppressing the number 102 that fabricates some mistakes in the plots
  y <- y[-102]
  # Ordering the two vectors so that they are in the same order
  genot.ok <- genot.okJA[order(rownames(genot.okJA)), ]
  y <- y[order(names(y))]

  genot.loop <- genot.ok

  #  Taking out the possible missing values in the y vector if there are any
  if (length(which(is.na(y))) > 0) {
    liste <- which(is.na(y))
    y <- y[ - liste, ]
  }
  # Sorting out the markers to have all the ones that are present on the map. Do not execute this line to have all the markers
  genot.loop <- genot.loop[, mapJA$SNP]
  p <- colMeans(genot.loop) / 2
  q <- 1 - p
  # Scaling the genotype matrix using a Van Raden method
  genot.scaled <- scale(genot.loop, center = 2 * p, scale = sqrt(2 * p * q))
  # With the thresh : we select the best model which is a little bit less conservative that the Benferroni model
  res_mlmm <- mlmm_allmodels(y, list(genot.scaled), list(KJA), maxsteps = 4, threshold=1e-4)
  # Making a Manhattan plot of the mixed model used before
  manhatt <- mlmm.gwas::manhattan.plot(res_mlmm, map = mapJA, steps = 1, hideCofactors = FALSE, chrToPlot = "all", unit = "bp", main = paste("Plot for axis", names(BLUPSJA)[i], "on table JA"))
  # Printing it with a line showing the threshold to determine where to stop
  manhatt
  abline(h = 5, col = "red", lwd = 2)
  # Saving the graph
  dev.print(device = png, file = paste0("table_JA/ACP/Axes_bruts/Manhattan plot of the p-values for all markers on the axis ",  names(BLUPSJA)[i], " of the AFC for table JA.png"), width = 1800)
}

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
```

Axes qui ont un QTL - D15; D26

### GWAS for all the BLUPS of table JF

```{r manhattan plot}
for (i in 1:ncol(BLUPSJF)) {
  # Verification to see if i is becoming bigger at each loop
  print(i)
  # Attribution of the BLUPS column i to a variable that we will be using here
  y <- BLUPSJF[, i]
  # Taking the rownames
  names(y) <- rownames(BLUPSJF)
  # Suppressing the number 102 that fabricates some mistakes in the plots
  y <- y[-102]
  # Ordering the two vectors so that they are in the same order
  genot.ok <- genot.okJF[order(rownames(genot.okJF)), ]
  y <- y[order(names(y))]

  genot.loop <- genot.ok

  #  Taking out the possible missing values in the y vector if there are any
  if (length(which(is.na(y))) > 0) {
    liste <- which(is.na(y))
    y <- y[ - liste, ]
  }
  # Sorting out the markers to have all the ones that are present on the map. Do not execute this line to have all the markers
  genot.loop <- genot.loop[, mapJF$SNP]
  p <- colMeans(genot.loop) / 2
  q <- 1 - p
  # Scaling the genotype matrix using a Van Raden method
  genot.scaled <- scale(genot.loop, center = 2 * p, scale = sqrt(2 * p * q))
  # With the thresh : we select the best model which is a little bit less conservative that the Benferroni model
  res_mlmm <- mlmm_allmodels(y, list(genot.scaled), list(KJF), maxsteps = 4, threshold=1e-4)
  # Making a Manhattan plot of the mixed model used before
  manhatt <- mlmm.gwas::manhattan.plot(res_mlmm, map = mapJF, steps = 1, hideCofactors = FALSE, chrToPlot = "all", unit = "bp", main = paste("Plot for axis", names(BLUPSJF)[i], "on table JF"))
  # Printing it with a line showing the threshold to determine where to stop
  #manhatt
  abline(h = 5, col = "red", lwd = 2)
  # Saving the graph
  #dev.print(device = png, file = paste0("table_JF/ACP/Axes_bruts/Manhattan plot of the p-values for all markers on the axis ",  names(BLUPSJA)[i], " of the AFC for table JF.png"), width = 1800)
}

# Cleaning up after the use of local variables that won't be used later on to preserve your working environment memory
```

Axes qui ont un QTL - D4; D30

# ?
```{r}

# Travaille sur axe D10 (joli)
names(BLUPSA)[6]
i <- 6
 yA <- BLUPSA[, i]
  # Taking the rownames
  names(yA) <- rownames(BLUPSA)
  # Suppressing the number 102 that fabricates some mistakes in the plots
  yA <- yA[-102]
  
  # Ordering the two vectors so that they are in the same order
  genot.okA <- genot.okA[order(rownames(genot.okA)), ]
  yA <- yA[order(names(yA))]

  genot.loopA <- genot.okA

  #  Taking out the possible missing values in the y vector if there are any
  if (length(which(is.na(yA))) > 0) {
    listeA <- which(is.na(yA))
    yA <- yA[ - listeA, ]
  }
  # Sorting out the markers to have all the ones that are present on the map. Do not execute this line to have all the markers
  genot.loopA <- genot.loopA[, mapA$SNP]
  # Calculating allelic frequencies
  pA <- colMeans(genot.loopA) / 2
  qA <- 1 - pA
  # Scaling the genotype matrix using a Van Raden method
  genot.scaledA <- scale(genot.loopA, center = 2 * pA, scale = sqrt(2 * pA * qA))
  # With the thresh : we select the best model which is a little bit less conservative that the Benferroni model
  res_mlmmA <- mlmm_allmodels(yA, list(genot.scaled), list(KA), maxsteps = 4, threshold=1e-4)

manhattA <- mlmm.gwas::manhattan.plot(res_mlmmA, map = mapA, steps = 1, hideCofactors = FALSE,
chrToPlot = "all", unit = "bp", main = paste("Plot for axis", names(BLUPSA)[i]))
abline(h = 5, col = "red", lwd = 2)
summary(res_mlmmA)
res_mlmmA[[4]]
hist(res_mlmmA[[2]])

snp_maxA <- which(-log10(res_mlmmA[[2]]) == max(-log10(res_mlmmA[[2]])))


names(snp_maxA)
bindA <- as.data.frame(cbind(yA, genot.okA[, names(snp_maxA)]))
boxplot(bindA[, 1]~ bindA[, 2])
table(bindA[, 2])
anova(lm(bindA[, 1]  ~ bindA[, 2]))

mapA[which(mapA$SNP == names(snp_maxA)), ]
names(mapA)
VA <-cor(genot.okA[, names(snp_maxA)], genot.okA)**2
hist(VA)
VA <- as.data.frame(VA)
colnames(VA[which(VA > 0.8)])
listVA <- colnames(VA[which(VA > 0.8)])

mapA[mapA$SNP %in% listVA, ]
nrow(mapA[mapA$SNP %in% listVA, ])
match(listVA, mapA$SNP)
pvalyA <- res_mlmmA[[2]][listVA]
avirerA <- cbind(mapA[match(listVA, mapA$SNP), ], -log10(pvalyA))
avirerA <- avirerA[which(avirerA$Chr != "Un"),]

plot(avirerA$Pos, avirerA[, 4], ylim = c(2, 6))

lessuivantsA <- mapA[which(mapA$Chr == "1B" & mapA$Pos >= mapA$Pos[snp_maxA]), ]
dim(lessuivantsA)
order(lessuivantsA$Pos)
lessuivantsA <- lessuivantsA[order(lessuivantsA$Pos), ]
cor(genot.okA[, lessuivantsA$SNP[1:2]])**2

lesprecedentsA <- mapA[which(mapA$Chr == "1B" & mapA$Pos <= mapA$Pos[snp_maxA]), ]
dim(lesprecedentsA)
order(lesprecedentsA$Pos)
lesprecedentsA <- lesprecedentsA[order(lesprecedentsA$Pos, decreasing = ), ]
cor(genot.okA[, lesprecedentsA$SNP[1:2]])**2
names(mapA)
rr

```

## Sans cofacteur

```{r manhattan mlmm step 1, fig.height = 4, fig.width = 8}
mlmm.gwas::plot_fwd_GWAS(x = res_mlmm, step = 1, snp_info = map, pval_filt = 0.1)

res_mlmm <- mygwas

# Manhattan plot avec carte

mip <- map
mip$Chr <- sprintf("%2d", mip$Chr)

```

## Step 2: 1 cofacteur

```{r manhattan mlmm step 2, fig.height= 4,  fig.width= 8}
plot_fwd_GWAS(x = mygwas, step = 2, snp_info = map, pval_filt = 0.1)
```

## Step 3: 2 cofacteurs

```{r manhattan mlmm step 3, fig.height= 4, fig.width= 8}
plot_fwd_GWAS(x = mygwas, step = 3, snp_info = map, pval_filt = 0.1)
```

## Etc ...

```{r}
plot_fwd_GWAS(x = mygwas, step = 5, snp_info = map, pval_filt = 0.1)

```

```{r}
plot_fwd_GWAS(x = mygwas, step = 10, snp_info = map, pval_filt = 0.1)
```

# Meilleur modèle selon le critère "mbonf"

```{r plot mbonf, fig.height = 4.5, fig.width = 5.5}
plot_step_table(mygwas, "maxpval")
```

```{r manhattan mlmm step 5, fig.height = 4, fig.width = 8}
plot_opt_GWAS(x = mygwas, opt = "mbonf", snp_info = map, pval_filt = 0.1)
plot_opt_GWAS(x = mygwas, opt = "thresh", snp_info = map, pval_filt = 0.1)

mygwas$opt_thresh

mygwas$RSSout
```
